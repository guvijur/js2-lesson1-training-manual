// Я всегда пишу много комментариев.
// Так я лучше понимаю материал.
//
// Создаю функцию-конструктор:
function Car(model, color, transmission, engine) {
    this.model = model;
    this.color = color;
    this.transmission = transmission;
    this.engine = engine;
}
// ВАЖНО! this - указывает, что данные свойства будут доступны объекту,
// который будет создан при помощи данной функции-конструктора.
//
// Теперь для создания объекта воспользуемся оператором new
// Вместо var буду использовать let, т.к. это не позволит мне дублировать
// переменные или объекты, что очень важно бри большом количестве кода на
// много-много строк, когда можно забыть, что ту или иную переменную
// или объект я использовал ранее.
// 
// Создам объект opel.
// Для этого я вызываю функцию-конструктор (далее ФК) и передаю ей требуемые значения:
// цвет, тип коробки передач, а так же параметры двигателя - объем и мощность 
// в виде объекта.
let opel = new Car("Astra H", "black", "AT", {volume: 1.8, power: 140});
// На данном этапе я запускаю index.html в браузере и с помощью консоли
// проверяю, что объект мой создался.
// Дополнительно я выведу это в консоль через console.log
console.log('Объект:');
console.log(opel);
// Создам ещё один объект.
let lada = new Car("Vesta", "white", "MT", {volume: 1.6, power: 106});
console.log('Объект:');
console.log(lada);
// Итого: я создал два экземпляра чертежа, каждый со своими свойствами.
// Как получать значения свойств объекта я знаю: objectname.property
// Вложенных объектов: objectname.insideobjectname.property
//
//
// ВТОРОЙ СПОСОБ СОЗДАНИЯ ОБЪЕКТОВ
// Метод Object.create
// Object - некий глобальный объект, встроенный в JS. 
// create - метод.
// Почему он нам больше подходит? Ну мы же хотим изучить наследование,
// а он как раз его реализует. Так же, он позволяет создавать объекты по
// прототипу, не определяя при этом конструктор.
// Попробую понять, о чём вообще я сейчас анписал. Пока в голове каша.
// 
// Создаю функцию, содержащую ряд элементов:
function Vehicle() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.color = "green";
}
// Что-же, мля, я написал? Я написал функцию, содержащую некие координаты x, y и z, 
// а так же указание на зелёный цвет чего-то. 
// С помощью this я сказал, что переменные x, y, z и color будут доступны из вне
// тем объектом, который будет создан благодаря этой функции.
// Я сейчас всё делаю по методичке, но изменяя некоторые сущности - например, 
// названия объектов и свойств. Мне в методичке кое-что было не понятно,
// тем более, что преподаватель, ведущий вебинар, не показал, зачем надо было
// создавать для Vehicle в прототипе метод move. Я не понимаю, зачем его надо было
// создавать именно в том месте кода. Я бы, например, создал его в конце данного блока кода.
//
// Продолжаю:
// Создаю функцию myCar(), которая через метод call будет вызывать функцию Vehicle()
function myCar() {
    Vehicle.call(this);
}
// Здесь this, как я понял, указывает на то, что все действия необходимо выполнять
// в рамках одной сущности (создаваемого в итоге объекта). Ну это логично.
// Далее, согласно методичке, я создаю для Car прототип объект на основе
// функции Vehicle.
// Вот, что я вычитал на одном интернет-ресурсе:
// Когда создаётся функция, в неё по умолчанию добавляется свойство prototype. 
// Значением свойства prototype является объект, содержащий общие свойства и методы, 
// которые доступны всем объектам, созданным с помощью этого конструктора.
// После этого мне стало всё более понятно, но сначала тот самый код, 
// который у меня вызывает вопросы:
myCar.prototype = Object.create(Vehicle.prototype);
myCar.prototype.constructor = myCar;
//
// Да, вот ещё, что я вычитал:
// У каждого объекта, созданного с помощью конструктора, есть неявно добавленное
// свойство constructor, содержащее ссылку на конструктор, с помощью которого был
// создан объект.
// 
// Теперь попробую это всё структурировать у себя в голове.
// Т.е., когда создаётся функция, а в нашем случае это myCar, то к ней автоматом
// добавляется стандартное, системное, если хотие, свойство prototype, значением
// которого будет объект, содержащий общие свойства и методы, которые доступны
// всем объектам, созданным с помощью этого конструктора.
// Таким образом в 80-ой строке я для свойства prototype функции myCar создал
// с помощью Object.create() объект Vehicle содержащий свойства, созданные,
// как я понимаю, функцией Vehicle(), т.е. - x, y, z и color.
// И теперь в строке 81 объекту свойству constructor свойства prototype объекта myCar
// , которое, как я вычитал, добавляется неявно, присваивается ссылка на конструктор,
// с помощью которого этот объект был создан. Ну мы же создаём этот объект на базе
// функции myCar?


























